(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{359:function(e,s,n){"use strict";n.r(s);var t=n(3),a=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[s("a",{attrs:{href:"https://blog.51cto.com/u_15281317/3007764",target:"_blank",rel:"noopener noreferrer"}},[e._v("深入理解BIO、NIO、AIO线程模型_柠檬不萌的技术博客_51CTO博客"),s("OutboundLink")],1)]),e._v(" "),s("blockquote",[s("p",[e._v("IO模型就是说用什么样的通道进行数据的发送和接收，首先要明确一点："),s("strong",[e._v("IO是操作系统与其他网络进行数据交互，JDK底层并没有实现IO，而是对操作系统内核函数做的一个封装")]),e._v("，IO代码进入底层其实都是native形式的。Java共支持3种网络编程IO模式："),s("strong",[e._v("BIO，NIO，AIO")]),e._v("。下文进行介绍")])]),e._v(" "),s("h2",{attrs:{id:"bio"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bio"}},[e._v("#")]),e._v(" BIO")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    BIO(Blocking IO) 又称同步阻塞IO，一个客户端由一个线程来进行处理，线程模型如下所示\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151645411.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty"}})]),e._v(" "),s("h3",{attrs:{id:"bio代码示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bio代码示例"}},[e._v("#")]),e._v(" BIO代码示例")]),e._v(" "),s("p",[e._v("登录后复制")]),e._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[e._v('public class SocketServer {\n    public static void main(String[] args) throws IOException {\n        //创建socket连接，端口为9000\n        ServerSocket serverSocket = new ServerSocket(9000);\n        while (true) {\n            System.out.println("等待连接。。");\n            //阻塞方法\n            Socket clientSocket = serverSocket.accept();\n            System.out.println("有客户端连接了。。");\n\n            //单线程连接，性能不好，下面开启多线程\n            //handler(clientSocket);\n\n            //开启多线程\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        handler(clientSocket);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n        }\n    }\n\n    private static void handler(Socket clientSocket) throws IOException {\n        byte[] bytes = new byte[1024];\n        System.out.println("准备read。。");\n        //接收客户端的数据，阻塞方法，没有数据可读时就阻塞\n        int read = clientSocket.getInputStream().read(bytes);\n        System.out.println("read完毕。。");\n        if (read != -1) {\n            System.out.println("接收到客户端的数据：" + new String(bytes, 0, read));\n        }\n        clientSocket.getOutputStream().write("HelloClient".getBytes());\n        clientSocket.getOutputStream().flush();\n    }\n}\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br")])]),s("p",[e._v("上边是BIO连接的示例代码，启动后可以通过telnet与 localhost 9000 建立连接，并发送字符串信息123，测试结果如下：\n"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151646352.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_02"}}),e._v(" "),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151646067.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_03"}}),e._v("\n测试成功，但BIO现在已经用的不多了，因为它在"),s("strong",[e._v("大并发下")]),e._v("有几个致命的缺点：")]),e._v(" "),s("ol",[s("li",[e._v("如果BIO使用单线程接受连接，则会阻塞其他连接，效率较低。")]),e._v(" "),s("li",[e._v("如果使用多线程虽然减弱了单线程带来的影响，但当有大并发进来时，会导致服务器线程太多，压力太大而崩溃。")]),e._v(" "),s("li",[e._v("就算使用线程池，也只能同时允许有限个数的线程进行连接，如果并发量远大于线程池设置的数量，还是与单线程无异")]),e._v(" "),s("li",[e._v("IO代码里read操作是阻塞操作，如果连接不做数据读写操作会导致线程阻塞，就是说只占用连接，不发送数据，则会浪费资源。比如线程池中500个连接，只有100个是频繁读写的连接，其他占着茅坑不拉屎，浪费资源！")]),e._v(" "),s("li",[e._v("另外多线程也会有线程切换带来的消耗")])]),e._v(" "),s("p",[e._v("综上所述，"),s("strong",[e._v("BIO方式已经不适用于如下的大并发场景，仅适用于连接数目比较小且固定的架构")]),e._v("。这种方式对服务器资源要求比较高，但BIO程序简单易理解。")]),e._v(" "),s("h2",{attrs:{id:"nio"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nio"}},[e._v("#")]),e._v(" NIO")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    为了解决BIO在大并发下存在的问题，诞生了NIO。NIO(Non Blocking IO)又称同步非阻塞IO。服务器实现模式为把多个连接(请求)放入集合中，只用一个线程可以处理多个请求(连接)，也就是**多路复用**。JDK1.4开始引入。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("NIO的同步非阻塞体现在：")]),e._v(" "),s("ol",[s("li",[s("p",[s("strong",[e._v("同步")]),e._v("：调用的结果会在本次调用后返回，不存在异步线程回调之类的。")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("非阻塞")]),e._v("：表现为线程不会一直在等待，把连接加入集合后，线程会一直轮询集合中的连接，有则处理，无则继续接受请求。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("**NIO的多路复用底层主要用的是Linux 内核函数（select，poll，epoll）来实现的**。windows不支持epoll实现，windows底层是基于winsock2的select函数实现的(不开源)。三种内核模型的区别如下所示！\n")])])])])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th"),e._v(" "),s("th",[e._v("select")]),e._v(" "),s("th",[e._v("poll")]),e._v(" "),s("th",[e._v("epoll(jdk 1.5及以上)")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("操作方式")]),e._v(" "),s("td",[e._v("遍历")]),e._v(" "),s("td",[e._v("遍历")]),e._v(" "),s("td",[e._v("回调")])]),e._v(" "),s("tr",[s("td",[e._v("底层实现数组")]),e._v(" "),s("td",[e._v("数组")]),e._v(" "),s("td",[e._v("链表")]),e._v(" "),s("td",[e._v("哈希表")])]),e._v(" "),s("tr",[s("td",[e._v("IO效率")]),e._v(" "),s("td",[e._v("每次调用都进行线性遍历，时间复杂度为O(n)")]),e._v(" "),s("td",[e._v("每次调用都进行线性遍历，时间复杂度为O(n)")]),e._v(" "),s("td",[e._v("事件通知方式，每当有IO事件就绪，系统注册的回调函数就会被调用，时间复杂度O(1)")])]),e._v(" "),s("tr",[s("td",[e._v("最大连接")]),e._v(" "),s("td",[e._v("有上限（1024个）")]),e._v(" "),s("td",[e._v("无上限")]),e._v(" "),s("td",[e._v("无上限")])])])]),e._v(" "),s("p",[s("strong",[e._v("NIO 有三大核心组件：")])]),e._v(" "),s("ol",[s("li",[s("strong",[e._v("Buffer(缓冲区)")]),e._v("：buffer 底层就是个数组")]),e._v(" "),s("li",[s("strong",[e._v("Channel(通道)")]),e._v("：channel 类似于流，每个 channel 对应一个 buffer缓冲区")]),e._v(" "),s("li",[s("strong",[e._v("Selector(多路复用器)")]),e._v("：channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理")])]),e._v(" "),s("p",[e._v("注意：NIO 的 Buffer 和 channel 都是既可以读也可以写，NIO的多路复用示意图如下：\n"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151646830.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_04"}})]),e._v(" "),s("p",[s("strong",[e._v("应用场景：")]),e._v("\nNIO方式适用于连接数目多且连接比较短（轻操作） 的架构， 比如聊天服务器， 弹幕系统， 服务器间通讯，编程比较复杂")]),e._v(" "),s("h3",{attrs:{id:"select、poll模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select、poll模型"}},[e._v("#")]),e._v(" select、poll模型")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    NIO底层在JDK1.4版本是用linux的内核函数select()或poll()来实现，selector每次都会轮询所有的sockchannel看下哪个channel有读写事件，有的话就处理，没有就继续遍历，select和poll模型作为NIO的早期实现，存在一定弊端。下面是一段代码，简单表述一下他们的弊端！\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("第一个版本："),s("strong",[e._v("NIO的早期版本模拟代码实现（select、poll）")])]),e._v(" "),s("p",[e._v("登录后复制")]),e._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[e._v("public class NioServer {\n\n    // 保存客户端连接\n    static List"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("SocketChannel")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(' channelList = new ArrayList<>();\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n\n        // 创建NIO ServerSocketChannel,与BIO的serverSocket类似\n        ServerSocketChannel serverSocket = ServerSocketChannel.open();\n        serverSocket.socket().bind(new InetSocketAddress(9000));\n\n        // 设置ServerSocketChannel为非阻塞, 配置为true，则和BIO类似\n        serverSocket.configureBlocking(false);\n        System.out.println("服务启动成功");\n\n        while (true) {\n            // 非阻塞模式accept方法不会阻塞，否则会阻塞\n            // NIO的非阻塞是由操作系统内部实现的，底层调用了linux内核的accept函数\n            SocketChannel socketChannel = serverSocket.accept();\n\n            if (socketChannel != null) { // 如果有客户端进行连接\n                System.out.println("连接成功");\n                // 设置SocketChannel为非阻塞\n                socketChannel.configureBlocking(false);\n                // 保存客户端连接在List中\n                channelList.add(socketChannel);\n            }\n\n            // 遍历连接进行数据读取\n            Iterator'),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("SocketChannel")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(' iterator = channelList.iterator();\n\n            while (iterator.hasNext()) {\n                SocketChannel sc = iterator.next();\n                ByteBuffer byteBuffer = ByteBuffer.allocate(128);\n                // 非阻塞模式read方法不会阻塞，否则会阻塞\n                int len = sc.read(byteBuffer);\n                // 如果有数据，把数据打印出来\n                if (len > 0) {\n                    System.out.println("接收到消息：" + new String(byteBuffer.array()));\n                } else if (len == -1) { // 如果客户端断开，把socket从集合中去掉\n                    iterator.remove();\n                    System.out.println("客户端断开连接");\n                }\n            }\n        }\n    }\n}\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br")])]),s("p",[e._v("从上述代码可以看到，NIO使用一个mian线程 + 一个数组 解决了BIO的痛点。具体解决方式如下")]),e._v(" "),s("ol",[s("li",[e._v("首先设置服务端连接的阻塞方式为false，代表非阻塞方式")]),e._v(" "),s("li",[e._v("非阻塞式接受客户端连接，意味着这段代码一直在轮询的跑，不会阻塞。")]),e._v(" "),s("li",[e._v("如果有客户端连接进来，就把这个连接放入list集合中")]),e._v(" "),s("li",[e._v("后续遍历list集合，使用非阻塞式读取数据")]),e._v(" "),s("li",[e._v("读取完成再次轮询跑代码")])]),e._v(" "),s("p",[e._v("测试如下：\n"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151646497.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_05"}})]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    这种方式虽然解决了BIO的部分痛点，但并不是很完美。**因为select和poll模型的底层实现、io效率、最大连接数在面对高并发时还存在一定弊端！他们的多路复用采用的是遍历Selector中所有的连接，然后对有事件的连接做出响应。** 假如连接数太多，有10000个连接，其中只有1000个连接有写数据，但是由于其他9000个连接并没有断开，我们还是要每次轮询遍历一万次，其中有十分之九的遍历都是无效的，这显然不是一个让人很满意的状态。**为了处理无效遍历的问题，在jdk1.5及以上版本引入了epoll模型**\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("h3",{attrs:{id:"epoll模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#epoll模型"}},[e._v("#")]),e._v(" epoll模型")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    **JDK1.5开始引入了epoll基于事件响应机制来优化NIO**。epoll模型解决了elect和poll模型的无效遍历问题，是NIO的核心。epool是基于事件响应的，类似于观察者模式！\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("NIO第二个版本："),s("strong",[e._v("使用epoll模型")]),e._v("后的代码示例")]),e._v(" "),s("p",[e._v("登录后复制")]),e._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[e._v('public class NioSelectorServer {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n\n        // 创建NIO ServerSocketChannel\n        ServerSocketChannel serverSocket = ServerSocketChannel.open();\n        serverSocket.socket().bind(new InetSocketAddress(9000));\n        // 设置ServerSocketChannel为非阻塞\n        serverSocket.configureBlocking(false);\n        // 打开Selector处理Channel，即创建epoll\n        Selector selector = Selector.open();\n        // 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣\n        serverSocket.register(selector, SelectionKey.OP_ACCEPT);\n        System.out.println("服务启动成功");\n\n        while (true) {\n            // 阻塞等待需要处理的事件发生\n            selector.select();\n\n            // 获取selector中注册的全部事件的 SelectionKey 实例\n            Set'),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("SelectionKey")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(" selectionKeys = selector.selectedKeys();\n            Iterator"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("SelectionKey")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(' iterator = selectionKeys.iterator();\n\n            // 遍历SelectionKey对事件进行处理\n            while (iterator.hasNext()) {\n                SelectionKey key = iterator.next();\n                // 如果是OP_ACCEPT事件，则进行连接获取和事件注册\n                if (key.isAcceptable()) {\n                    ServerSocketChannel server = (ServerSocketChannel) key.channel();\n                    SocketChannel socketChannel = server.accept();\n                    socketChannel.configureBlocking(false);\n                    // 这里只注册了读事件，如果需要给客户端发送数据可以注册写事件\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                    System.out.println("客户端连接成功");\n                } else if (key.isReadable()) {  // 如果是OP_READ事件，则进行读取和打印\n                    SocketChannel socketChannel = (SocketChannel) key.channel();\n                    ByteBuffer byteBuffer = ByteBuffer.allocate(128);\n                    int len = socketChannel.read(byteBuffer);\n                    // 如果有数据，把数据打印出来\n                    if (len > 0) {\n                        System.out.println("接收到消息：" + new String(byteBuffer.array()));\n                    } else if (len == -1) { // 如果客户端断开连接，关闭Socket\n                        System.out.println("客户端断开连接");\n                        socketChannel.close();\n                    }\n                }\n                //从事件集合里删除本次处理的key，防止下次select重复处理\n                iterator.remove();\n            }\n        }\n    }\n}\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br"),s("span",{staticClass:"line-number"},[e._v("51")]),s("br"),s("span",{staticClass:"line-number"},[e._v("52")]),s("br"),s("span",{staticClass:"line-number"},[e._v("53")]),s("br")])]),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    在使用epoll模型之后，对简单版本的NIO做了优化处理，可以理解为在第一个版本的NIO上，又增加了一个就绪事件列表集合，这个集合中存放着有事件响应的连接，然后开启一个线程去监听这个集合，有元素的话就进行处理。\n\n    总结：NIO整个调用流程就是Java调用了操作系统的内核函数来创建Socket，获取到Socket的文件描述符，再创建一个Selector对象，对应操作系统的Epoll描述符，将获取到的Socket连接的文件描述符的事件绑定到Selector对应的Epoll文件描述符上，进行事件的异步通知，这样就**实现了使用一条线程，并且不需要太多的无效的遍历，将事件处理交给了操作系统内核(操作系统硬中断程序实现)，大大提高了效率。**\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("h3",{attrs:{id:"深入hotpost源码分析epoll模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深入hotpost源码分析epoll模型"}},[e._v("#")]),e._v(" 深入hotpost源码分析epoll模型")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    NIO第二个版本的代码中，与简单版本最主要的代码区别在以下三行代码\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("登录后复制")]),e._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[e._v("// 1. 打开Selector处理Channel，即创建epoll ，创建多路复用器\nSelector selector = Selector.open();\n\n// 2. 把ServerSocketChannel链接注册到selector多路复用器上，并且selector对客户端accept连接操作感兴趣\nserverSocket.register(selector, SelectionKey.OP_ACCEPT);\n\n// 3. 阻塞等待需要处理的事件发生\nselector.select();\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("这三行代码内部是优化的核心，下面一一介绍！")]),e._v(" "),s("p",[s("strong",[e._v("2.3.1. Selector selector = Selector.open();")])]),e._v(" "),s("p",[e._v("登录后复制")]),e._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[e._v("    public static Selector open() throws IOException {\n        return SelectorProvider.provider().openSelector();\n    }\n\n ========================= SelectorProvider.provider() =======================\n\n    public static SelectorProvider provider() {\n        synchronized (lock) {\n            if (provider != null)\n                return provider;\n            return AccessController.doPrivileged(\n                new PrivilegedAction"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("SelectorProvider")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("() {\n                    public SelectorProvider run() {\n                            if (loadProviderFromProperty())\n                                return provider;\n                            if (loadProviderAsService())\n                                return provider;\n                            // 我们在Windows环境下，默认创建的是WindowsSelectorProvider，如下所示\n                            provider = sun.nio.ch.DefaultSelectorProvider.create();\n                            return provider;\n                        }\n                    });\n        }\n    }\n\n======================= 默认创建的是WindowsSelectorProvider =======================\n\t  public static SelectorProvider create() {\n\t        return new WindowsSelectorProvider();\n\t    }\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br")])]),s("p",[e._v("​\t\t进入open方法源码中，可以看到创建的是WindowsSelectorProvider，而"),s("strong",[e._v("项目发布一般都是在linux上，所以需要进入hotport源码中看一下Linux平台的实现。这中现象也是JVM的跨平台性的体现")]),e._v("。进入hotpost源码发现如果是linux环境，则创建"),s("strong",[e._v("EpollSelectorProvider")]),e._v("。也发现Linux上实现是基于Epoll模型！")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151648366.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_06"}})]),e._v(" "),s("p",[e._v("所以 SelectorProvider.provider().openSelector() 其实是EpollSelectorProvider.openSelector(),代码如下所示！")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151646955.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_07"}}),e._v("\n可以看到 "),s("strong",[e._v("EPollSelectorImpl")]),e._v(" 是具体的实现，那么在EPollSelectorImpl实例化时做了什么事情呢？\n"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151646099.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_08"}}),e._v("\n在这个 EPollArray 包装类中调用了一个 "),s("strong",[e._v("epoll_create")]),e._v(" 的本地方法，"),s("strong",[e._v("创建了一个epoll对象")]),e._v("，并返回一个非负数作为文件描述符，用于对epoll接口的所有后续调用。这个方法属于linux操作系统内核中的方法。"),s("strong",[e._v("至此Selector.open()方法解释完毕，总的来说就是创建了一个linux内核层面的Epoll对象！")]),e._v(" "),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151647710.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_09"}})]),e._v(" "),s("p",[s("strong",[e._v("2.3.2. serverSocket.register(selector, SelectionKey.OP_ACCEPT)")])]),e._v(" "),s("p",[e._v("查看这个方法的源码，同样要使用LInux下的平台中的EpollSelectorProvider的register方法，核心代码如下：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151647450.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_10"}}),e._v("\n这个方法是把当前连接注册到第一步EPollSelectorImpl实例化时生成的EPollArray的集合中，此时并没有事件驱动。直到 selector.select()方法调用linux内核函数epoll_ctl")]),e._v(" "),s("p",[s("strong",[e._v("2.3.3. selector.select()")])]),e._v(" "),s("p",[e._v("这个select方法内部会调用doselect()方法，这个方法同样要使用LInux下的平台中的EpollSelectorProvider\n"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151647045.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_11"}}),e._v("\n在这个poll方法中，分别调用了Linux核心函数 "),s("strong",[e._v("epoll_ctl")]),e._v(" 和 "),s("strong",[e._v("epoll_wait")]),e._v("，下面分别解释其含义")]),e._v(" "),s("ol",[s("li",[s("strong",[e._v("epoll_ctl：")]),e._v(" 负责真正去关联socketChannel 和 epoll实例(selector)的关系。如果客户端连接（socketChannel）有发送事件，就会把存在于EPollArray中的这个连接放入epoll实例中的就绪事件列表(rdlist)中去。\n"),s("strong",[e._v("其中这个放入就绪事件列表的操作是怎么做的呢？")]),e._v("\n放入操作并非是java去做，每当服务端收到客户端的连接，且该链接有响应事件时，就是使用操作系统的硬中断功能把该连接放入就绪事件列表中去。后续遍历就绪事件列表中的元素即可，减少了无效遍历。")]),e._v(" "),s("li",[s("strong",[e._v("epoll_wait")]),e._v("：监听就绪事件列表中的元素，如果没有数据则阻塞。如果有数据，则把数据放入selectedKeys中，供java代码获取元素，响应事件！")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151647885.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_12"}})]),e._v(" "),s("h3",{attrs:{id:"nio与redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nio与redis"}},[e._v("#")]),e._v(" NIO与redis")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    Redis就是典型的基于epoll的NIO线程模型(nginx也是)，epoll实例收集所有事件(连接与读写事件)，把有数据交互的连接放入就绪事件列表中，由一个服务端线程连续处理所有就绪事件列表中的命令。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151647827.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_13"}}),e._v("\n在ae_epoll.c源码中也发现有 "),s("strong",[e._v("epoll_create")]),e._v("、"),s("strong",[e._v("epoll_ctl")]),e._v(" 和 "),s("strong",[e._v("epoll_wait")]),e._v("，原理与上文讲的类似")]),e._v(" "),s("p",[s("strong",[e._v("问题一：为什么 redis 不建议用 bigkey？")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    bigkey的big体现在单个value值很大，一般认为超过10KB就是bigkey。由于redis底层用的是NIO，多路复用一个线程，如果存在bigkey的话，这个bigkey就会占用这个线程较大的时间，导致其他连接的数据交互阻塞，所以不建议使用bigkey。注意：这里说的阻塞并不是 异步非阻塞的阻塞。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("3. AIO")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    AIO自JDK1.7以后才开始支持，是异步非阻塞的，客户端与服务端的连接(accept)、数据读写(read、write)不再由main线程去执行，而是开辟一个回调函数，**当客户端与服务端建立连接时，把这个客户端的连接传入回调函数中，由服务端启动一个子线程去处理**，这就完成了异步操作！适用于连接数较多且连接时间较长的应用。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[s("strong",[e._v("AIO与BIO、NIO的不同之处在于：")])]),e._v(" "),s("ol",[s("li",[e._v("AIO是 "),s("strong",[e._v("异步非阻塞")]),e._v("模型")]),e._v(" "),s("li",[e._v("NIO是 "),s("strong",[e._v("同步非阻塞")]),e._v("模型")]),e._v(" "),s("li",[e._v("BIO是 "),s("strong",[e._v("同步阻塞")]),e._v("模型")])]),e._v(" "),s("p",[e._v("AIO代码示例")]),e._v(" "),s("p",[e._v("登录后复制")]),e._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[e._v("public class AIOServer {\n\n    public static void main(String[] args) throws Exception {\n    \t//创建服务端\n        final AsynchronousServerSocketChannel serverChannel =\n                AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(9000));\n\n\t\t//使用CompletionHandler异步处理客户端连接\n        serverChannel.accept(null, new CompletionHandler"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("AsynchronousSocketChannel,")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v('() {\n            @Override\n            public void completed(AsynchronousSocketChannel socketChannel, Object attachment) {\n                try {\n                    System.out.println("2--"+Thread.currentThread().getName());\n\n                    // 在此接收客户端连接，如果不写这行代码后面的客户端连接连不上服务端\n                    serverChannel.accept(attachment, this);\n                    System.out.println(socketChannel.getRemoteAddress());\n                    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n                    //使用CompletionHandler异步读取数据\n                    socketChannel.read(buffer, buffer, new CompletionHandler'),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("Integer,")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("ByteBuffer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v('() {\n                        @Override\n                        public void completed(Integer result, ByteBuffer buffer) {\n                            System.out.println("3--"+Thread.currentThread().getName());\n                            buffer.flip();\n                            System.out.println(new String(buffer.array(), 0, result));\n                            socketChannel.write(ByteBuffer.wrap("HelloClient".getBytes()));\n                        }\n\n                        @Override\n                        public void failed(Throwable exc, ByteBuffer buffer) {\n                            exc.printStackTrace();\n                        }\n                    });\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            @Override\n            public void failed(Throwable exc, Object attachment) {\n                exc.printStackTrace();\n            }\n        });\n\n        System.out.println("1--"+Thread.currentThread().getName());\n        Thread.sleep(Integer.MAX_VALUE);\n    }\n}\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br")])]),s("p",[s("strong",[e._v("AIO作为异步非阻塞模型，理论上来说应该被广泛使用，但大多数公司并没有使用AIO，而是使用了netty，为什么？")])]),e._v(" "),s("ol",[s("li",[e._v("首先AIO得底层实现仍使用Epoll，并没有很好的实现异步，在性能上对比NIO没有太大优势")]),e._v(" "),s("li",[e._v("其次AIO的代码逻辑比较复杂，且Linux上AIO还不够成熟")]),e._v(" "),s("li",[e._v("Netty在NIO上做了很多异步的封装，是异步非阻塞框架")])]),e._v(" "),s("p",[e._v("4. BIO、NIO、AIO的对比")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/202207151647033.png",alt:"深入理解BIO、NIO、AIO线程模型_线程模型、netty_14"}}),e._v("\n一个关于"),s("strong",[e._v("同步异步")]),e._v("与"),s("strong",[e._v("阻塞非阻塞")]),e._v("的段子:")]),e._v(" "),s("p",[e._v("老张爱喝茶，废话不说，煮开水。\n出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。")]),e._v(" "),s("ol",[s("li",[e._v("老张把水壶放到火上，立等水开。（同步阻塞） 老张觉得自己有点傻")]),e._v(" "),s("li",[e._v("老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。")]),e._v(" "),s("li",[e._v("老张把响水壶放到火上，立等水开。（异步阻塞）老张觉得这样傻等意义不大")]),e._v(" "),s("li",[e._v("老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。")])]),e._v(" "),s("p",[s("strong",[e._v("所谓同步异步，只是对于水壶而言。")])]),e._v(" "),s("ol",[s("li",[e._v("普通水壶，同步")]),e._v(" "),s("li",[e._v("响水壶，异步。")]),e._v(" "),s("li",[e._v("虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。\n同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。")])]),e._v(" "),s("p",[s("strong",[e._v("所谓阻塞非阻塞，仅仅对于老张而言。")])]),e._v(" "),s("ol",[s("li",[e._v("立等的老张，阻塞")]),e._v(" "),s("li",[e._v("看电视的老张，非阻塞。")])])])}),[],!1,null,null,null);s.default=a.exports}}]);