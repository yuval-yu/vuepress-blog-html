(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{328:function(n,s,a){"use strict";a.r(s);var e=a(3),t=Object(e.a)({},(function(){var n=this,s=n._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[n._v("#")]),n._v(" 前言")]),n._v(" "),s("blockquote",[s("p",[s("code",[n._v("Condition")]),n._v(" 接口的实现类有两个, 本篇只介绍 "),s("code",[n._v("AbstractQueuedSynchronizer")]),n._v(" 中的实现 "),s("code",[n._v("ConditionObject")])])]),n._v(" "),s("p",[n._v("通过上一篇"),s("code",[n._v("Condition介绍及使用")]),n._v("我们看到在创建"),s("code",[n._v("Condition")]),n._v("对象时调用的是'newCondition()', 并且 "),s("code",[n._v("Condition")]),n._v("只能在"),s("code",[n._v("lock")]),n._v("锁内使用, 我们可以大胆猜想:")]),n._v(" "),s("ol",[s("li",[s("code",[n._v("Condition")]),n._v(" 和"),s("code",[n._v("AQS")]),n._v("相似, 内部都是一个链表结构")]),n._v(" "),s("li",[n._v("在调用"),s("code",[n._v("#await")]),n._v("方法时会将当前线程从"),s("code",[n._v("AQS")]),n._v("列队中取出, 加入到"),s("code",[n._v("Condition")]),n._v("的列队中")]),n._v(" "),s("li",[n._v("在调用"),s("code",[n._v("#signal")]),n._v("方法时, 会将线程从"),s("code",[n._v("Condition")]),n._v("中取出第一个, 加入到"),s("code",[n._v("AQS")]),n._v("列队中")]),n._v(" "),s("li",[n._v("在调用"),s("code",[n._v("#signalAll")]),n._v("方法时, 会将线程从"),s("code",[n._v("Condition")]),n._v("中取出全部线程, 加入到"),s("code",[n._v("AQS")]),n._v("列队中")]),n._v(" "),s("li",[n._v("在插入"),s("code",[n._v("AQS")]),n._v("列队前可能会依据公平锁or非公平锁来决定是否竞争锁后插入 "),s("code",[n._v("[Doug Lea 说我这条猜错了]")])])]),n._v(" "),s("h2",{attrs:{id:"类结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类结构"}},[n._v("#")]),n._v(" 类结构")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("interface Condition {\n    void await() throws InterruptedException;\n    void signal();\n    void signalAll();\n}\n\ninterface Lock {\n    Condition newCondition();\n}\n\nclass ReentrantLock implements Lock{\n    public Condition newCondition() {\n        return sync.newCondition();\n    }\n    abstract static class Sync extends AbstractQueuedSynchronizer {\n        final ConditionObject newCondition() {\n            return new ConditionObject();\n        }\n    }\n\n}\n\nabstract class AbstractQueuedSynchronizer{\n    public class ConditionObject implements Condition, java.io.Serializable {\n        private transient Node firstWaiter;\n        private transient Node lastWaiter;\n        public ConditionObject() { }\n    }\n    static final class Node {\n        /**\n         * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态\n         */\n        static final int CANCELLED =  1;\n        /**\n         * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行\n         */\n        static final int SIGNAL    = -1;\n        /**\n         * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，该节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中\n         */\n        static final int CONDITION = -2;\n        /**\n         * 表示下一次共享式同步状态获取，将会无条件地传播下去\n         */\n        static final int PROPAGATE = -3;\n    \n        /** 等待状态 */\n        volatile int waitStatus;\n    \n        /** 前驱节点，当节点添加到同步队列时被设置（尾部添加） */\n        volatile Node prev;\n    \n        /** 后继节点 */\n        volatile Node next;\n    \n        /** 等待队列中的后续节点。如果当前节点是共享的，那么字段将是一个 SHARED 常量，也就是说节点类型（独占和共享）和等待队列中的后续节点共用同一个字段 */\n        Node nextWaiter;\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br"),s("span",{staticClass:"line-number"},[n._v("46")]),s("br"),s("span",{staticClass:"line-number"},[n._v("47")]),s("br"),s("span",{staticClass:"line-number"},[n._v("48")]),s("br"),s("span",{staticClass:"line-number"},[n._v("49")]),s("br"),s("span",{staticClass:"line-number"},[n._v("50")]),s("br"),s("span",{staticClass:"line-number"},[n._v("51")]),s("br"),s("span",{staticClass:"line-number"},[n._v("52")]),s("br"),s("span",{staticClass:"line-number"},[n._v("53")]),s("br"),s("span",{staticClass:"line-number"},[n._v("54")]),s("br"),s("span",{staticClass:"line-number"},[n._v("55")]),s("br"),s("span",{staticClass:"line-number"},[n._v("56")]),s("br"),s("span",{staticClass:"line-number"},[n._v("57")]),s("br"),s("span",{staticClass:"line-number"},[n._v("58")]),s("br"),s("span",{staticClass:"line-number"},[n._v("59")]),s("br")])]),s("p",[n._v("从类结构上来看我们没有猜错, "),s("code",[n._v("ConditionObject")]),n._v(" 内部构成的也是"),s("code",[n._v("Node")]),n._v("对象,证明猜想1 是对的!")]),n._v(" "),s("blockquote",[s("p",[n._v("有一个小细节, 这里的"),s("code",[n._v("Node")]),n._v("对象只加了"),s("code",[n._v("transient")]),n._v(" 反序列化, 而没有加"),s("code",[n._v("volatile")]),n._v(". 这是因为"),s("code",[n._v("Condition")]),n._v("是在lock内部使用的, 也就是"),s("code",[n._v("#lock")]),n._v("和"),s("code",[n._v("#unLock")]),n._v("之间, 在这里运行的程序因为加了锁,所以都是单线程的")])]),n._v(" "),s("h2",{attrs:{id:"源码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#源码"}},[n._v("#")]),n._v(" 源码")]),n._v(" "),s("h3",{attrs:{id:"conditionobject-await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#conditionobject-await"}},[n._v("#")]),n._v(" conditionObject.await()")]),n._v(" "),s("blockquote",[s("p",[n._v("将数据添加至"),s("code",[n._v("Condition")]),n._v("等待列队中,并释放当前线程,当线程被唤醒后从"),s("code",[n._v("※")]),n._v("位置开始抢占锁继续向下执行")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("class ConditionObject implements Condition{\n    public final void await() throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        // 1. 加入 Condition 列队, 并返回当前线程的node对象\n        Node node = addConditionWaiter();\n        // 2. 释放锁并将当前节点从AQS列队中移出,并返回当前线程重入次数state\n        int savedState = fullyRelease(node);\n        int interruptMode = 0;\n        // 3. 循环判断此node是否在AQS列队中, 如果不在则park\n        while (!isOnSyncQueue(node)) {\n            LockSupport.park(this);\n            // 线程中断相关,略过\n            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n                break;\n        }\n        // ※ 到这个位置说明当前线程已经被unpark了\n        // acquireQueued 自旋获取锁并返回线程是否中断(AQS有讲过)\n        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n            interruptMode = REINTERRUPT;\n        // 移除被取消的节点\n        if (node.nextWaiter != null) // clean up if cancelled\n            unlinkCancelledWaiters();\n        if (interruptMode != 0)\n            // 如果线程已经被中断，则根据之前获取的interruptMode的值来判断是继续中断还是抛出异常\n            reportInterruptAfterWait(interruptMode);\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br")])]),s("h4",{attrs:{id:"addconditionwaiter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#addconditionwaiter"}},[n._v("#")]),n._v(" addConditionWaiter()")]),n._v(" "),s("blockquote",[s("p",[n._v("加入 "),s("code",[n._v("Condition")]),n._v(" 列队, 并返回当前线程的node对象, "),s("strong",[n._v("注意: 在"),s("code",[n._v("Condition")]),n._v("不为空时添加的是"),s("code",[n._v("nextWaiter")]),n._v("字段, 而"),s("code",[n._v("AQS")]),n._v("使用的是"),s("code",[n._v("pre")]),n._v("和"),s("code",[n._v("next")])])])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("class ConditionObject implements Condition{\n    private Node addConditionWaiter() {\n        // Condition 列队最后一个节点\n        Node t = lastWaiter;\n        // 如果Condition 列队最后一个被取消则遍历删除取消的节点\n        if (t != null && t.waitStatus != Node.CONDITION) {\n            unlinkCancelledWaiters();\n            t = lastWaiter;\n        }\n        // 将当前线程构造出一个node , 等待标识为 -2 (等待)\n        Node node = new Node(Thread.currentThread(), Node.CONDITION);\n        // 列队为空则直接赋值\n        if (t == null)\n            firstWaiter = node;\n        else\n            t.nextWaiter = node;\n        lastWaiter = node;\n        // 返回当前线程node\n        return node;\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br")])]),s("h4",{attrs:{id:"fullyrelease-node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fullyrelease-node"}},[n._v("#")]),n._v(" fullyRelease(node)")]),n._v(" "),s("blockquote",[s("p",[n._v("释放锁,并返回当前线程重入次数的status")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("class ConditionObject implements Condition{\n    final int fullyRelease(Node node) {\n        // 解锁是否成功的标识\n        boolean failed = true;\n        try {\n            // 2.1 这里是AQS的重入次数的标识\n            int savedState = getState();\n            // 解锁,AQS方法, 前面讲过\n            if (release(savedState)) {\n                failed = false;\n                return savedState;\n            } else {\n                throw new IllegalMonitorStateException();\n            }\n        } finally {\n            if (failed)\n                // 如果解锁失败了, 直接修改状态为 1\n                node.waitStatus = Node.CANCELLED;\n        }\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br")])]),s("h5",{attrs:{id:"getstate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#getstate"}},[n._v("#")]),n._v(" getState()")]),n._v(" "),s("blockquote",[s("p",[n._v("这里是AQS的重入次数的标识")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("abstract class AbstractQueuedSynchronizer{\n    protected final int getState() {\n        return state;\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])]),s("h4",{attrs:{id:"isonsyncqueue-node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#isonsyncqueue-node"}},[n._v("#")]),n._v(" isOnSyncQueue(node)")]),n._v(" "),s("blockquote",[s("p",[n._v("判断该node是否在AQS列队中")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("abstract class AbstractQueuedSynchronizer{\n    final boolean isOnSyncQueue(Node node) {\n        // 1. node.waitStatus == Node.CONDITION\n        // 2. node.prev == null\n        if (node.waitStatus == Node.CONDITION || node.prev == null)\n            return false;\n        // 3. node.next != null\n        if (node.next != null) // If has successor, it must be on queue\n            return true;\n        \n         /*\n         * node.prev can be non-null, but not yet on queue because\n         * the CAS to place it on queue can fail. So we have to\n         * traverse from tail to make sure it actually made it.  It\n         * will always be near the tail in calls to this method, and\n         * unless the CAS failed (which is unlikely), it will be\n         * there, so we hardly ever traverse much.\n         */\n         // 遍历 AQS 列队, 确定是否在列队中 \n        return findNodeFromTail(node);\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br")])]),s("ol",[s("li",[n._v("节点等待状态为等待,那它一定在"),s("code",[n._v("Condition")]),n._v("列队中")]),n._v(" "),s("li",[n._v("使用到"),s("code",[n._v("pre")]),n._v("字段的只有"),s("code",[n._v("AQS")]),n._v(","),s("code",[n._v("AQS")]),n._v("除了代表当前获取锁线程的头结点,其他节点的"),s("code",[n._v("pre")]),n._v("字段都是有值的, 而"),s("code",[n._v("AQS")]),n._v("的首个并不属于排队的节点; 所以它在"),s("code",[n._v("Condition")]),n._v("列队中")]),n._v(" "),s("li",[n._v("使用到"),s("code",[n._v("next")]),n._v("字段的只有"),s("code",[n._v("AQS")]),n._v(", "),s("code",[n._v("next != null")]),n._v("说明在"),s("code",[n._v("AQS")]),n._v("列队中")])]),n._v(" "),s("h5",{attrs:{id:"findnodefromtail-node-node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#findnodefromtail-node-node"}},[n._v("#")]),n._v(" findNodeFromTail(Node node)")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("/**\n * Returns true if node is on sync queue by searching backwards from tail.\n * 如果节点在同步队列上，则通过从尾部向后搜索返回true\n * Called only when needed by isOnSyncQueue.\n * 仅供isOnSyncQueue方法调用\n * @return true if present\n */\nprivate boolean findNodeFromTail(Node node) {\n    Node t = tail;\n    for (;;) {\n        if (t == node)\n            return true;\n        if (t == null)\n            return false;\n        t = t.prev;\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br")])]),s("p",[n._v("在将"),s("code",[n._v("node")]),n._v("追加到"),s("code",[n._v("AQS列队尾端时, 是先")]),n._v("node.prev = tail"),s("code",[n._v(",然后进行cas操作将")]),n._v("node`节点追加入列队的.在运行此处代码时可能在cas自旋中. 所以需要从尾部进行遍历")]),n._v(" "),s("blockquote",[s("p",[n._v("源码注释上写道: node.prev是非空的，但还没放在队列上，因为将它放在队列上的cas可能会失败。所以我们必须从尾部开始遍历以确保它确实成功了。在对这个方法的调用中，它总是在尾部附近，除非CAS失败(这是不太可能的)，否则它将在那里，因此我们几乎不会遍历太多。(软件翻译的,理解就好)")])]),n._v(" "),s("h3",{attrs:{id:"conditionobject-signal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#conditionobject-signal"}},[n._v("#")]),n._v(" conditionObject.signal()")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("public final void signal() {\n    // 判断当前线程是否获取锁,没有获取就抛出异常(方法很简单,不贴了)\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    // Condition 中首个等待的节点\n    Node first = firstWaiter;\n    if (first != null)\n        // 实际唤醒的方法\n        doSignal(first);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br")])]),s("h4",{attrs:{id:"dosignal-first"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dosignal-first"}},[n._v("#")]),n._v(" doSignal(first)")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("private void doSignal(Node first) {\n    do {\n        // 先把firstWaiter的给改为下一个等待的,如果下一个为null,那么把lastWaiter也改为null\n        if ( (firstWaiter = first.nextWaiter) == null)\n            lastWaiter = null;\n        // 1. 将需要进行操作的node单独拎出来\n        first.nextWaiter = null;\n        // 循环遍历整个Condition列队\n        // 2. transferForSignal(first) 转移节点到AQS列队,成功true,失败false\n    } while (!transferForSignal(first) &&\n             (first = firstWaiter) != null);\n            \n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br")])]),s("ol",[s("li",[n._v("注意上方已经将 firstWaiter 的值给修改了, 所以first和firstWaiter指向的位置是不同的, 修改first的时候firstWaiter不会改变")]),n._v(" "),s("li",[s("code",[n._v("#transferForSignal")]),n._v(" "),s("ul",[s("li",[n._v("如果成功了, while的条件为"),s("code",[n._v("false && ? = false")]),n._v(" ;打断循环")]),n._v(" "),s("li",[n._v("如果失败了, while的条件为"),s("code",[n._v("true&& ?")]),n._v(" "),s("ul",[s("li",[s("code",[n._v("Condition")]),n._v(" 还有等待数据,"),s("code",[n._v("true&& true")]),n._v("; 执行下一个等待数据")]),n._v(" "),s("li",[s("code",[n._v("Condition")]),n._v(" 没有等待数据,"),s("code",[n._v("true&& false")]),n._v("; 打断循环")])])])])])]),n._v(" "),s("h5",{attrs:{id:"transferforsignal-first"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#transferforsignal-first"}},[n._v("#")]),n._v(" transferForSignal(first)")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("abstract class AbstractQueuedSynchronizer{\n    final boolean transferForSignal(Node node) {\n        /*\n         * If cannot change waitStatus, the node has been cancelled.\n         */\n         // 1. cas将等待状态改为0, 如果修改失败说明这个节点被取消了,返回false\n        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n            return false;\n    \n        /*\n         * Splice onto queue and try to set waitStatus of predecessor to\n         * indicate that thread is (probably) waiting. If cancelled or\n         * attempt to set waitStatus fails, wake up to resync (in which\n         * case the waitStatus can be transiently and harmlessly wrong).\n         */\n         // 插入AQS列队,并返回当前节点在AQS中的前置节点\n        Node p = enq(node);\n        int ws = p.waitStatus;\n        // ws > 0 前置节点被取消\n        // 2. compareAndSetWaitStatus(p, ws, Node.SIGNAL) cas前置节点从当前状态改为等待\n        if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n            LockSupport.unpark(node.thread);\n        return true;\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br")])]),s("ol",[s("li",[s("code",[n._v("Condition")]),n._v(" 中的waitstatus有两种状态, 等待or取消\n"),s("ul",[s("li",[n._v("等待:修改等待状态为0后继续执行")]),n._v(" "),s("li",[n._v("取消:"),s("code",[n._v("doSignal(first)")]),n._v("方法在调用前已经把当前节点删除了,返回false后while循环会继续执行下去,这时取消的节点已经不在"),s("code",[n._v("Condition")]),n._v("列队中了")])])]),n._v(" "),s("li",[n._v("如果这时前置节点取消了, 就不会执行后面的cas操作")])]),n._v(" "),s("h3",{attrs:{id:"conditionobject-signalall"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#conditionobject-signalall"}},[n._v("#")]),n._v(" conditionObject.signalAll()")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("public final void signalAll() {\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        // 这里和signal()不同, 其他一致\n        doSignalAll(first);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br")])]),s("h4",{attrs:{id:"dosignalall-node-first"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dosignalall-node-first"}},[n._v("#")]),n._v(" doSignalAll(Node first)")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("private void doSignalAll(Node first) {\n    lastWaiter = firstWaiter = null;\n    do {\n        Node next = first.nextWaiter;\n        first.nextWaiter = null;\n        transferForSignal(first);\n        first = next;\n    } while (first != null);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br")])]),s("p",[n._v("直接循环, "),s("code",[n._v("Condition")]),n._v("中数据全部转移到"),s("code",[n._v("AQS")]),n._v("列队中")]),n._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),s("ol",[s("li",[s("code",[n._v("AQS")]),n._v("的列队是双向链表,并且第一个节点的"),s("code",[n._v("thread")]),n._v("为"),s("code",[n._v("null")]),n._v("为代表获取锁的当前线程;而"),s("code",[n._v("Condition")]),n._v("的列队是单向的一个链表,")]),n._v(" "),s("li",[s("code",[n._v("Condition")]),n._v("接口的"),s("code",[n._v("#await")]),n._v(","),s("code",[n._v("#signal")]),n._v(","),s("code",[n._v("#signalAll")]),n._v("三个方法必须在"),s("code",[n._v("lock")]),n._v("内执行")]),n._v(" "),s("li",[s("code",[n._v("Condition")]),n._v("中的列队被唤醒后是有序的加入到"),s("code",[n._v("AQS")]),n._v("列队中的")]),n._v(" "),s("li",[n._v("一个"),s("code",[n._v("lock")]),n._v("可以维护多个"),s("code",[n._v("Condition")]),n._v("列队, 我们可以让指定列队停止或运行")])])])}),[],!1,null,null,null);s.default=t.exports}}]);